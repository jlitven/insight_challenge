#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Date    : 2016-07-08 09:55:37
# @Author  : Joshua Litven (jlitven@gmail.com)
# @Link    : https://github.com/jlitven
# @Version : $Id$

"""
Find the median degree of a graph generated by Venmo payment data.
"""
import sys
from collections import namedtuple
from collections import defaultdict
from datetime import datetime
from datetime import timedelta
import pdb
import json

class Edge():
    """Represent an edge in a venmo graph."""
    def __init__(self, v1, v2, date_str):
        """
        Create an Edge.
        Input:
        v1 - A vertex in the graph
        v2 - A vertex in the graph
        date_str - A time stamp, with format YYYY-MM-DDTHH:MM:SSZ
                    e.g. 2016-03-28T23:25:21Z
        Output:
            An edge
        """
        self.v1 = v1
        self.v2 = v2
        self.vertices = (v1, v2)
        self.created_time = datetime.strptime(date_str, '%Y-%m-%dT%H:%M:%SZ')

class VenmoGraph():
    """
    A graph G = (V, E) is a collection of vertices (V) and edges (E).
    A vertex contains its name and degree.
    An edge contains the two vertices it connects.
    """
    def __init__(self):
        """Create a Graph."""
        self.edges = []
        self.degrees = {}
        self.degree_buckets = defaultdict(int)  # num of vertices with degree
        self.window_seconds = 60

    def add_edge(self, edge):
        """Add the edge to the graph, and update the vertex degrees."""

        if self.edges and edge.created_time > self.newest_time():
            # Remove edges older than the window
            threshold_time = edge.created_time - timedelta(seconds=self.window_seconds)
            remove_indices = []
            # TODO: Make this more efficient
            for count, e in enumerate(self.edges[::-1]):
                if e.created_time < threshold_time:
                    remove_index = len(self.edges) - count - 1
                    remove_indices.append(remove_index)
            #     else:
            #         break
            # for count, e in enumerate(self.edges):
            #     if e.created_time < threshold_time:
            #         remove_index = count
            #         remove_indices.append(remove_index)

            print remove_indices

            for index in remove_indices:
                self.remove_edge(index)

        self.edges.append(edge)
        # bubble down to correct order

        for vertex in edge.vertices:
            if vertex not in self.degrees:
                self.degrees[vertex] = 1
                self.degree_buckets[1] += 1
            else:
                degree = self.degrees[vertex]
                self.degree_buckets[degree] -= 1
                self.degree_buckets[degree + 1] += 1
                self.degrees[vertex] += 1

        # TODO: Make this more efficient
        #self.edges.sort(key=lambda e: e.created_time)

    def get_value(self, index):
        """Return the value from the buckets."""
        bucket_index = 0
        for key, val in self.degree_buckets.iteritems():
            # key = bucket value
            # val = bucket size
            if bucket_index + val > index:
                return key
            else:
                bucket_index += val
        pdb.set_trace()

    def remove_edge(self, index):
        """Remove the edge from the graph, and any disconnected vertices."""
        edge = self.edges[index]
        for vertex in edge.vertices:
            degree = self.degrees[vertex]
            self.degree_buckets[degree] -= 1
            self.degrees[vertex] -= 1
            if self.degrees[vertex] == 0:
                del self.degrees[vertex]
            else:
                self.degree_buckets[degree - 1] += 1
        del self.edges[index]

    def newest_time(self):
        """Return the newest created time of an edge."""
        return self.edges[-1].created_time

    def oldest_time(self):
        """Return the oldest created time of an edge."""
        return self.edges[0].created_time

    def __str__(self):
        """Format the vertices and edges as a string."""
        result = 'Edges:\n'
        for e in self.edges:
            result += '{} - {} ({})\n'.format(e.v1, e.v2, e.created_time)

        return result

    def within_time_window(self, edge):
        """Return True if the time is within the graph's 60-second
        window or newer.
        """
        if not self.edges:
            return True

        newest_time = self.edges[-1].created_time
        starting_time = newest_time - timedelta(seconds=self.window_seconds)
        return edge.created_time >= starting_time

    def get_median_degree_new(self):
        """
        Calculate the median degree of the vertices. Assumes the
        vertices are sorted."""
        length = len(self.degrees)
        if length % 2 == 0:
            index = length / 2
            return (self.get_value(index) + self.get_value(index - 1)) / 2.0
        else:
            index = (length - 1) / 2
            return float(self.get_value(index))

    def get_median_degree(self):
        """
        Calculate the median degree of the vertices. Assumes the
        vertices are sorted."""
        # TODO: Don't sort
        degrees = sorted(self.degrees.values())
        length = len(degrees)
        if length % 2 == 0:
            index = length / 2
            return (degrees[index] + degrees[index - 1]) / 2.0
        else:
            index = (length - 1) / 2
            return float(degrees[index])


def gen_median_degrees(input_file):
    """
    Generate the median degrees of a graph generated from
    input taken from the Venmo API.
    """
    graph = VenmoGraph()

    with open(input_file, 'r') as source:
        for line in source:
            transaction = json.loads(line)
            edge = Edge(transaction['actor'],
                        transaction['target'],
                        transaction['created_time'])
            if graph.within_time_window(edge):
                graph.add_edge(edge)
            yield graph.get_median_degree_new()

def main():
    """Write the degree median of a source Venmo Graph to file."""
    if len(sys.argv) < 3:
        print 'Usage: {} input.txt output.txt'.format(sys.argv[0])
        return
    input_file = sys.argv[1]
    output_file = sys.argv[2]

    with open(output_file, 'w') as output:
        for median in gen_median_degrees(input_file):
            output.write("{:.2f}".format(median) + '\n')

if __name__ == '__main__':
    sys.exit(main())
